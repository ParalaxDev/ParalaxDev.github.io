{"version":3,"sources":["components/VertexDisplacementCore.js","components/Header.js","images/pfp.png","images/test.png","App.js","reportWebVitals.js","index.js"],"names":["trans3","x","y","VertexDisplacementCore","renderWidth","renderHeight","size","useSpring","xy","config","mass","tension","friction","props","start","Date","now","useEffect","scene","THREE","camera","renderer","alpha","canvas","document","querySelector","setClearColor","setSize","body","appendChild","domElement","geometry","material","uniforms","time","type","value","fragmentShader","vertexShader","sphere","color","add","position","z","animate","requestAnimationFrame","render","id","style","top","width","overflow","transform","interpolate","calc","window","innerWidth","innerHeight","trans1","Header","set","randColour","Math","floor","random","console","log","className","onMouseMove","clientX","clientY","href","h1","to","App","backgroundColor","height","zIndex","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.3d03314c.chunk.js","sourcesContent":["import React, { useEffect } from 'react'\r\nimport * as THREE from 'three';\r\nimport { useSpring, animated } from 'react-spring'\r\n\r\n// import glsl from 'babel-plugin-glsl/macro';\r\n\r\nconst calc = (x, y) => [x - window.innerWidth / 2, y - window.innerHeight / 2]\r\nconst trans3 = (x, y) => `translate3d(${x / 6}px,${y / 6}px,0)`\r\n\r\nconst VertexDisplacementCore = ({ renderWidth, renderHeight, size }) => {\r\n\r\n    const [props, set] = useSpring(() => ({ xy: [0, 0], config: { mass: 10, tension: 550, friction: 140 } }))\r\n\r\n\r\n    // const uniforms = {\r\n    //   u_time: {type: 'float', value: 0},\r\n    //   u_amplitude: {type: 'float', value: 4},\r\n    //   u_frequency: {type: 'float', value: 1}\r\n    // }\r\n\r\n    const start = Date.now()\r\n\r\n    useEffect(() => {\r\n\r\n        var scene = new THREE.Scene();\r\n        var camera = new THREE.PerspectiveCamera(30, renderWidth / renderHeight, 1, 1000);\r\n        const renderer = new THREE.WebGLRenderer({ alpha: true, canvas: document.querySelector('#mainCanvas') });\r\n        renderer.setClearColor(0xffffff, 0);\r\n        renderer.setSize(renderWidth, renderHeight);\r\n        document.body.appendChild(renderer.domElement);\r\n        const geometry = new THREE.SphereGeometry(size, 200, 200);\r\n\r\n        const uniforms = {\r\n            time: { type: 'f', value: 0.0 }\r\n        }\r\n        const material = new THREE.ShaderMaterial({\r\n            uniforms: uniforms,\r\n            fragmentShader: fragmentShader(),\r\n            vertexShader: pog()\r\n        })\r\n        var material2 = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n\r\n        const sphere = new THREE.Mesh(geometry, material);\r\n        scene.add(sphere);\r\n\r\n        camera.position.z = 100;\r\n        var animate = function () {\r\n            requestAnimationFrame(animate);\r\n            material.uniforms['time'].value = .00015 * (Date.now() - start);\r\n            renderer.setSize(renderWidth, renderHeight);\r\n            renderer.render(scene, camera);\r\n        };\r\n        animate();\r\n    })\r\n\r\n    // #region shaders\r\n    const vertexShader = () => {\r\n        return `\r\n\r\n\r\n        //\r\n    // GLSL textureless classic 3D noise \"cnoise\",\r\n    // with an RSL-style periodic variant \"pnoise\".\r\n    // Author:  Stefan Gustavson (stefan.gustavson@liu.se)\r\n    // Version: 2011-10-11\r\n    //\r\n    // Many thanks to Ian McEwan of Ashima Arts for the\r\n    // ideas for permutation and gradient selection.\r\n    //\r\n    // Copyright (c) 2011 Stefan Gustavson. All rights reserved.\r\n    // Distributed under the MIT license. See LICENSE file.\r\n    // https://github.com/ashima/webgl-noise\r\n    //\r\n    \r\n\r\n    vec3 mod289(vec3 x)\r\n    {\r\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n    }\r\n    \r\n    vec4 mod289(vec4 x)\r\n    {\r\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n    }\r\n    \r\n    vec4 permute(vec4 x)\r\n    {\r\n      return mod289(((x*34.0)+1.0)*x);\r\n    }\r\n    \r\n    vec4 taylorInvSqrt(vec4 r)\r\n    {\r\n      return 1.79284291400159 - 0.85373472095314 * r;\r\n    }\r\n    \r\n    vec3 fade(vec3 t) {\r\n      return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n    }\r\n    \r\n    // Classic Perlin noise\r\n    float cnoise(vec3 P)\r\n    {\r\n      vec3 Pi0 = floor(P); // Integer part for indexing\r\n      vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\r\n      Pi0 = mod289(Pi0);\r\n      Pi1 = mod289(Pi1);\r\n      vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n      vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n      vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n      vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n      vec4 iz0 = Pi0.zzzz;\r\n      vec4 iz1 = Pi1.zzzz;\r\n    \r\n      vec4 ixy = permute(permute(ix) + iy);\r\n      vec4 ixy0 = permute(ixy + iz0);\r\n      vec4 ixy1 = permute(ixy + iz1);\r\n    \r\n      vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n      vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n      gx0 = fract(gx0);\r\n      vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n      vec4 sz0 = step(gz0, vec4(0.0));\r\n      gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n      gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n    \r\n      vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n      vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n      gx1 = fract(gx1);\r\n      vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n      vec4 sz1 = step(gz1, vec4(0.0));\r\n      gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n      gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n    \r\n      vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n      vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n      vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n      vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n      vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n      vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n      vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n      vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n    \r\n      vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n      g000 *= norm0.x;\r\n      g010 *= norm0.y;\r\n      g100 *= norm0.z;\r\n      g110 *= norm0.w;\r\n      vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n      g001 *= norm1.x;\r\n      g011 *= norm1.y;\r\n      g101 *= norm1.z;\r\n      g111 *= norm1.w;\r\n    \r\n      float n000 = dot(g000, Pf0);\r\n      float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n      float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n      float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n      float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n      float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n      float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n      float n111 = dot(g111, Pf1);\r\n    \r\n      vec3 fade_xyz = fade(Pf0);\r\n      vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n      vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n      float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n      return 2.2 * n_xyz;\r\n    }\r\n    \r\n    // Classic Perlin noise, periodic variant\r\n    float pnoise(vec3 P, vec3 rep)\r\n    {\r\n      vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\r\n      vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\r\n      Pi0 = mod289(Pi0);\r\n      Pi1 = mod289(Pi1);\r\n      vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n      vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n      vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n      vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n      vec4 iz0 = Pi0.zzzz;\r\n      vec4 iz1 = Pi1.zzzz;\r\n    \r\n      vec4 ixy = permute(permute(ix) + iy);\r\n      vec4 ixy0 = permute(ixy + iz0);\r\n      vec4 ixy1 = permute(ixy + iz1);\r\n    \r\n      vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n      vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n      gx0 = fract(gx0);\r\n      vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n      vec4 sz0 = step(gz0, vec4(0.0));\r\n      gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n      gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n    \r\n      vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n      vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n      gx1 = fract(gx1);\r\n      vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n      vec4 sz1 = step(gz1, vec4(0.0));\r\n      gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n      gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n    \r\n      vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n      vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n      vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n      vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n      vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n      vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n      vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n      vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n    \r\n      vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n      g000 *= norm0.x;\r\n      g010 *= norm0.y;\r\n      g100 *= norm0.z;\r\n      g110 *= norm0.w;\r\n      vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n      g001 *= norm1.x;\r\n      g011 *= norm1.y;\r\n      g101 *= norm1.z;\r\n      g111 *= norm1.w;\r\n    \r\n      float n000 = dot(g000, Pf0);\r\n      float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n      float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n      float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n      float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n      float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n      float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n      float n111 = dot(g111, Pf1);\r\n    \r\n      vec3 fade_xyz = fade(Pf0);\r\n      vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n      vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n      float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n      return 2.2 * n_xyz;\r\n    }\r\n    \r\n    // Include the Ashima code here!\r\n    \r\n    varying vec2 vUv;\r\n    varying float noise;\r\n    varying vec3 vNormal;\r\n    \r\n    float turbulence( vec3 p ) {\r\n        float w = 100.0;\r\n        float t = -.5;\r\n        for (float f = 1.0 ; f <= 10.0 ; f++ ){\r\n            float power = pow( 2.0, f );\r\n            t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\r\n        }\r\n        return t;\r\n    }\r\n    \r\n    void main() {\r\n    \r\n        vUv = uv;\r\n        vNormal = normalMatrix * normalize(normal);\r\n    \r\n        noise = 10.0 *  -.10 * turbulence( .5 * normal );\r\n        float b = 5.0 * pnoise( 0.05 * position, vec3( 100.0 ) );\r\n        float displacement = - 10. * noise + b;\r\n    \r\n        vec3 newPosition = position + normal * displacement;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\r\n    \r\n    }\r\n\r\n    `\r\n    }\r\n\r\n    function pog() {\r\n        return `\r\n    \r\n    \r\nvarying vec2 vUv;\r\nvarying float noise;\r\nuniform float time;\r\nvarying vec3 vNormal;\r\n  \r\n  vec3 mod289(vec3 x)\r\n{\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 mod289(vec4 x)\r\n{\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x)\r\n{\r\n  return mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r)\r\n{\r\n  return 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nvec3 fade(vec3 t) {\r\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n}\r\n\r\n// Classic Perlin noise\r\nfloat cnoise(vec3 P)\r\n{\r\n  vec3 Pi0 = floor(P); // Integer part for indexing\r\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\r\n  Pi0 = mod289(Pi0);\r\n  Pi1 = mod289(Pi1);\r\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n  vec4 iz0 = Pi0.zzzz;\r\n  vec4 iz1 = Pi1.zzzz;\r\n\r\n  vec4 ixy = permute(permute(ix) + iy);\r\n  vec4 ixy0 = permute(ixy + iz0);\r\n  vec4 ixy1 = permute(ixy + iz1);\r\n\r\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n  gx0 = fract(gx0);\r\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n  vec4 sz0 = step(gz0, vec4(0.0));\r\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n  gx1 = fract(gx1);\r\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n  vec4 sz1 = step(gz1, vec4(0.0));\r\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n  g000 *= norm0.x;\r\n  g010 *= norm0.y;\r\n  g100 *= norm0.z;\r\n  g110 *= norm0.w;\r\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n  g001 *= norm1.x;\r\n  g011 *= norm1.y;\r\n  g101 *= norm1.z;\r\n  g111 *= norm1.w;\r\n\r\n  float n000 = dot(g000, Pf0);\r\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n  float n111 = dot(g111, Pf1);\r\n\r\n  vec3 fade_xyz = fade(Pf0);\r\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \r\n  return 2.2 * n_xyz;\r\n}\r\n\r\n// Classic Perlin noise, periodic variant\r\nfloat pnoise(vec3 P, vec3 rep)\r\n{\r\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\r\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\r\n  Pi0 = mod289(Pi0);\r\n  Pi1 = mod289(Pi1);\r\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\r\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n  vec4 iz0 = Pi0.zzzz;\r\n  vec4 iz1 = Pi1.zzzz;\r\n\r\n  vec4 ixy = permute(permute(ix) + iy);\r\n  vec4 ixy0 = permute(ixy + iz0);\r\n  vec4 ixy1 = permute(ixy + iz1);\r\n\r\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\r\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\r\n  gx0 = fract(gx0);\r\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n  vec4 sz0 = step(gz0, vec4(0.0));\r\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\r\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\r\n  gx1 = fract(gx1);\r\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n  vec4 sz1 = step(gz1, vec4(0.0));\r\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\r\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\r\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\r\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\r\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\r\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\r\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\r\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\r\n\r\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n  g000 *= norm0.x;\r\n  g010 *= norm0.y;\r\n  g100 *= norm0.z;\r\n  g110 *= norm0.w;\r\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n  g001 *= norm1.x;\r\n  g011 *= norm1.y;\r\n  g101 *= norm1.z;\r\n  g111 *= norm1.w;\r\n\r\n  float n000 = dot(g000, Pf0);\r\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n  float n111 = dot(g111, Pf1);\r\n\r\n  vec3 fade_xyz = fade(Pf0);\r\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\r\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \r\n  return 2.2 * n_xyz;\r\n}\r\n\r\nfloat turbulence( vec3 p ) {\r\n    float w = 100.0;\r\n    float t = -.5;\r\n    for (float f = 1.0 ; f <= 10.0 ; f++ ){\r\n        float power = pow( 2.0, f );\r\n        t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\r\n    }\r\n    return t;\r\n}\r\n\r\nvoid main() {\r\n\r\n    vUv = uv;\r\n    vNormal = normalMatrix * normalize(normal);\r\n\r\n    // add time to the noise parameters so it's animated\r\n    noise = 10.0 *  -.10 * turbulence( .5 * normal + time );\r\n    float b = 5.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );\r\n    float displacement = - noise + b;\r\n    \r\n    vec3 newPosition = position + normal * displacement;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\r\n\r\n}\r\n    `\r\n    }\r\n\r\n\r\n    // varying vec3 vUv;\r\n    // varying vec3 vNormal;\r\n\r\n    // void main() {\r\n    //   vUv = position;\r\n    //   vNormal = normalMatrix * normalize(normal);\r\n\r\n    //   vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n    //   gl_Position = projectionMatrix * modelViewPosition; \r\n    // }\r\n\r\n    function fragmentShader() {\r\n        return `\r\n\r\n\r\n    varying vec3 vNormal;\r\n    void main(void) {\r\n      vec3 viewNv  = normalize(vNormal);\r\n      vec3 nvColor = viewNv * 0.5 + 0.5;\r\n      gl_FragColor  = vec4(nvColor, 1.0);\r\n    }\r\n`\r\n    }\r\n    // #endregion\r\n\r\n    return (\r\n        <animated.canvas id='mainCanvas' style={{ position: 'absolute', top: '0px', width: '100%', overflow:'hidden',transform: props.xy.interpolate(trans3) }}></animated.canvas>\r\n    )\r\n}\r\n\r\nexport default VertexDisplacementCore\r\n","import React, { useState, useEffect } from 'react'\r\nimport { useSpring, animated } from 'react-spring'\r\n// import ReactDOM from 'react-dom';\r\nimport VertexDisplacementCore from '../components/VertexDisplacementCore'\r\nimport '../css/Header.css'\r\n\r\nconst calc = (x, y) => [x - window.innerWidth / 2, y - window.innerHeight / 2]\r\nconst trans1 = (x, y) => `translate3d(${x / 15}px,${y / 15}px,0)`\r\nconst trans2 = (x, y) => `translate3d(${x / 8}px,${y / 8}px,0)`\r\nconst trans3 = (x, y) => `translate3d(${x / 6}px,${y / 6}px,0)`\r\nconst trans4 = (x, y) => `translate3d(${x / 3.5}px,${y / 3.5}px,0)`\r\n\r\nconst Header = () => {\r\n\r\n    const [props, set] = useSpring(() => ({ xy: [0, 0], config: { mass: 10, tension: 550, friction: 140 } }))\r\n\r\n    const randColour = `hsl(${Math.floor(Math.random() * 360) + 1}, 74%, 57%)`\r\n    console.log(randColour)\r\n\r\n    return (\r\n        <div className='wrapper'>\r\n            <div className='parallax-core' onMouseMove={({ clientX: x, clientY: y }) => set({ xy: calc(x, y) })} />\r\n            <div className='bg' >\r\n                <VertexDisplacementCore renderWidth={window.innerWidth-25} renderHeight={window.innerHeight-25} size={15} />\r\n            </div>\r\n            <div className='navbar-container'>\r\n                <div className='navbar'>\r\n                    <a href='/' className='left'>Folio 2021</a>\r\n                    <a href='#programming' className='right'>Programming</a>\r\n                    <a href='#graphics' className='right'>Graphics</a>\r\n                    <a href='#about' className='right'>About</a>\r\n                </div>\r\n            </div>\r\n            <div className='title-container' >\r\n                <animated.h1 className='title' style={{ transform: props.xy.to(trans1) }}>Paralax</animated.h1>\r\n            </div>\r\n            {/* <div className='bg-colour' style={{backgroundColor: randColour, height: '100vh', width: '100vw', position: 'absolute', zIndex: '-10000', top: '0px'}} /> */}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Header\r\n","export default __webpack_public_path__ + \"static/media/pfp.57bd1100.png\";","export default __webpack_public_path__ + \"static/media/test.1ad7fc23.png\";","import './App.css';\nimport Header from './components/Header'\nimport InfoSection from './components/InfoSection'\nimport profilePicture from './images/pfp.png' \nimport test from './images/test.png' \n\nfunction App() {\n\n    const randColour = `hsl(${Math.floor(Math.random() * 360) + 1}, 74%, 57%)`\n\n\n\n    return (\n        <div className=\"App\">\n\n            <div className='bg-colour' style={{ backgroundColor: randColour, height: '100vh', width: '100%', zIndex: '-10000', top: '0px' }} />\n\n            <Header className='snap-sections' />\n            {/* <InfoSection id='about' heading='About Me' subheading=\"Hi,👋 I'm Will, a 15 year old Graphic Design and Software Development Student  from the UK\" randcolor={randColour} image={profilePicture}/>\n            <InfoSection id='graphics' heading='Graphics' subheading=\"I'm currently studying Graphic Design for GCSE, and have created an extesive portfolio of my work\" randcolor={randColour} image={test}/>\n            <InfoSection id='programming' heading='Programming' subheading=\"I also like to create unique websites using react and css, but I'm also proficient in HTML, CSS, C#, JavaScript, TypeScript \" randcolor={randColour} image={test}/> */}\n        </div>\n    )\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}